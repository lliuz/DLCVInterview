**Q1: 两根香，一根烧完1小时，如何测量15分钟**

 先将一根香的一端点燃，另一根香的两端全部点燃。当第二根香全部烧完时，此时已经过了半个小时。再将第一根香的另一端也点燃，那么此时第一根香剩下部分烧完的时间就是 15 min。

**Q2: 一个硬币，正面概率0.7，反面概率0.3，现在有一瓶水，怎么掷能让两个人公平的喝到水**



**54张扑克牌，平均分成3份，大小王在一份的概率**

54 张牌分成 3 等份，共有 M=  C(54, 18) * C(36, 18) * C(18, 18) 种分法。

其中大小王在同一份的分法有 N= C(3, 1) * C(52, 16) * C(36, 18) * C(18, 18) 种。

因此所求概率为P= N / M=17/53。



### 几何分布

几何分布（Geometric distribution）是离散型概率分布。其中一种定义为：在伯努利试验中，前k-1次皆失败，第k次成功的概率。

$$P(X=k) = (1-p)^{k - 1} p$$

期望为:

$E(X) = 1*P(X = 1) + 2*P(X=2) + ... + K*P(X=K) = \frac{1}{p}$ 是一个等差乘等比的求和

可以用错位相减法：E(x)乘上等比系数，再对位相减，用等比数列求和公式。或者裂项相消法。

方差为:

 $Var(X) = E(X^2) - E(X)^2 = \frac{1 - p}{p^2}$

 前一项是幂次乘等比(不太好求，写出式子后能发现是期望中表达式的求导)

https://blog.csdn.net/sinat_37321923/article/details/77493672



**两个人轮流抛硬币，先抛到正面的赢，问先抛的人赢的概率**

P(赢) = 1/2 + 1/4 * 1/2(第一局平第二局赢) + 1/4 * 1/4 * 1/2 (前两局平，第三局赢) + ...

​         = sum{0, 正无穷} (1/4)^i * 1/2

用等比数列求和公式: P = 1/2 (1 - 1/4^正无穷)/ (1 - 1/4) = 2/3 = 0.667



**用 `rand_n` (0~n - 1的随机整数生成器) 生成 `rand_m`(0~m - 1的随机整数生成器)**

几种情况: 

1. n > m，直接循环，只要采到 < m 的数返回即可。每个数产生的概率为 sum{0, 正无穷} 1/n * ((n - m) / n)^i = 1/n / (1 - (n - m) / n) = 1/m (计算方式和上一题抛硬币一致)。
2. 2 < n < m < n^2，先用 `rand_kn = k * rand_n() + rand_k() ` 生成一个略大于 m 的 `rand_kn`，再调用 case 1，但这种只能用于 k <= n 的情况(因为加法是用来补足乘法的空隙)。
3. n == 2，直接生成 k 位二进制，使得 2^k 略大于 m，再调用 case 1 即可。

对于每种情况，都可以先通过 case 1 生成 `rand_2`，再调用 case3，但是时间负责度会较高。



**64匹马，8个跑道，选跑最快的4匹马需要比赛多少次**





**三个线程循环打印ABC**

```python
import threading
import sys
import time
def showa():
    while True:
        lockc.acquire()   #获取对方的锁，释放自己的锁
        print('a',end='')
        sys.stdout.flush()   #释放缓冲区
        locka.release()
        time.sleep(0.2)
def showb():
    while True:
        locka.acquire()
        print('b',end='')
        sys.stdout.flush() 
        lockb.release()
        time.sleep(0.2)
def showc():
    while True:
        lockb.acquire()
        print('c',end='')
        sys.stdout.flush()
        lockc.release()
        time.sleep(0.2)
if __name__=='__main__':
    locka=threading.Lock()  #定义3个互斥锁
    lockb=threading.Lock()
    lockc=threading.Lock()
 
    t1=threading.Thread(target=showa)   #定义3个线程
    t2=threading.Thread(target=showb)
    t3=threading.Thread(target=showc)
 
    locka.acquire()   #先锁住a,b锁，保证先打印a
    lockb.acquire()
 
    t1.start()
    t2.start()
    t3.start()
```







输入两个值n和k，n表示我们有从1到n个整数，然后将这些整数都字符串化之后按字典排序，找出其中第K大的。例如:n=15,k=5.那么1-15字符串化之后排序如下:1,10,11,12,13,14,15,2,3,4,5,6,7,8,9。其中第5大的就为13。



